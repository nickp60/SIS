import argparse
import os
import re
import sys

from Bio import SeqIO # , SearchIO
from Bio.SeqRecord import SeqRecord


def get_args():
    parser = argparse.ArgumentParser(
        description="Use coords file to scaffold some contigs against " +
        "a reference; fill with N's")
    parser.add_argument( "coords", action="store", type=str,
                         help="Nucmer's show-coords coordinates")
    parser.add_argument("contigs", action="store",
                        help="path to your contigs")
    parser.add_argument("-f", "--fill", action="store_true", dest="fill",
                        default=False,
                        help="output as single file; default: %(default)s")
    args = parser.parse_args()
    return(args)

# Parse the coordinate file generated by nucmer or promer
def parse_coords(coords_filename) :
    info_array  = []
    coords_file = open(coords_filename)
    for line in coords_file :
        match =  re.match("\s+(\d+)\s+(\d+)\s+\|\s+(\d+)\s+(\d+)\s+\|\s+(\d+)\s+(\S+)\s+\|\s+(\S+)\s+\|(.*)\s(\S+)", line)
        #                     s1        e1           s2      e2           len1   en 2         percent
        if match and match.group(1) != "[S1]" : #ignore header line
            s1     = int(match.group(1))
            e1     = int(match.group(2))
            s2     = int(match.group(3))
            e2     = int(match.group(4))
            len1   = int(match.group(5))
            len2   = int(match.group(6))
            idy    = float(match.group(7))
            extra  = match.group(8)
            contig = match.group(9)
            info_array.append([s1,e1,s2,e2,contig])
    coords_file.close()
    info_array.sort()
    return info_array

def write_scaffold(coords, contigs):
    """ for each contig in coords, read through the contigs, find the rec, and write it out
    this is probably very wasteful, but oh well
    """
    new_seq = ""
    with open(contigs, "r") as inf:
        for idx, line in enumerate(coords):
            sys.stderr.write(" ".join([str(x) for x in line]) + "\n")
            FOUND = False
            for rec in SeqIO.parse(inf, "fasta"):
                sys.stderr.write(rec.id + "\n")
                sys.stderr.write(line[4] + "\n")
                if rec.id == line[4]:
                    FOUND = True
                    if line[2] < line[3]:
                        new_seq = new_seq + rec.seq
                    else:
                        new_seq = new_seq + rec.reverse_complement().seq
                    if idx == len(coords) - 1:  #  if not the last entry, calculate the gap length
                        gap_len = coods[idx + 1][0] - line[1]
                        new_seq = new_seq + ("N" * gap_len)
            if not FOUND:
                sys.stderr.write("Contig %s found in coords file but not in contigs!  Exiting...\n" % line[4])
                sys.exit(1)
    sys.stdout.write(SeqRecord(new_seq, id="SIS_scaffolds").format("fasta"))


def main():
    args = get_args()
    coords = parse_coords(args.coords)
    write_scaffold(coords, args.contigs)


if __name__ == "__main__":
    main()
